基本架构和环境

* `基本惯例`_

  * `比特和字节序`_
  * `指令操作数`_
  * `数值表示`_
  * `分段寻址`_
  * `CPUID/CR/MSR 新语法`_
  * `异常`_

* `执行环境`_

  * `操作模式`_
  * `环境概览`_
  * `内存组织`_
  * `基本寄存器`_
  * `操作数大小`_
  * `操作数寻址`_

基本惯例
=========

比特和字节序
------------

在内存数据结构的示意图中，较小的地址出现在图的底部，地址向顶部增加。比特位位置从右到左编
号，一个比特的置位后的数值等于对应位置的 2 次幂。Intel 64 和 IA-32 处理器是小端字节序
机器，这意味着一个字长中的字节编号从位于最低地址的最低字节开始。

.. image:: image/byteorder.png
    :width: 60%

指令操作数
----------

当指令以符号形式表示时，使用的是 IA-32 汇编语言的一个子集。在这个子集中，指令具有以下格
式： ::

    label: mnemonic argument1, argument2, argument3

标签（label）
    是一个标识符，后面跟一个冒号
助记符（mnemonic）
    是具有相同功能的一类指令操作码的助记名称
操作数（operands）
    操作数 argument1, argument2, argument3 是可选的。根据操作码，操作数可能从零到三个
    不等。当存在时，它们可以是字面量或者数据项的标识符。操作数标识符要么是寄存器名称，要
    么是被关联到在程序其他部分声明的数据项。

当算术或逻辑指令中存在两个操作数时，右操作数是源操作数，左操作数是目标操作数。例如： ::

    LOADREG: MOV EAX, SUBTOTAL

在这个例子中，LOADREG 是一个标签，MOV 是操作码的助记标识符，EAX 是目标操作数，SUBTOTAL
是源操作数。一些汇编语言可能会将源和目标操作数的顺序颠倒。

数值表示
---------

十六进制（基数 16）数是由一串十六进制数字组成的字符串，后面紧跟字符 'H'（例如 0F82EH）。
十六进制数字包括以下字符集：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, 和 F。

二进制（基数 2）数是由一串 1 和 0 组成的字符串，有时后面跟着字符 'B'（例如，1010B）。
字符标识 'B' 仅在可能对数字类型产生混淆的情况下使用。

分段寻址
---------

处理器使用字节寻址，这意味着内存以字节序列组织和访问。无论正在访问一个字节还是多个字节，
都使用字节地址来定位内存中的字节或字节序列。可以寻址的内存范围称为地址空间。

处理器还支持分段寻址。这是一种寻址形式，程序可能拥有许多独立的地址空间，称为段。例如，程
序可以将代码（指令）和程序栈保存在不同的段中。代码的地址将始终引用代码段空间，程序栈的地
址将始终引用栈段空间。以下符号用于指定段内的字节地址： ::

    segment-register:byte-address

例如，以下段地址标识了 DS 寄存器指向的段中地址 FF79H 处的字节： ::

    DS:FF79H

以下段地址标识了代码段中的指令地址，CS 寄存器指向代码段，EIP 寄存器包含指令的地址： ::

    CS:EIP

CPUID/CR/MSR 新语法
--------------------

获取 CPU 特性标志、状态和系统信息可以通过使用 CPUID 指令、检查控制寄存器（CR）标志位以
及读取 MSR 寄存器来实现。为了更清晰地表示这些信息，我们正在采用一种新的语法。如下：

.. image:: image/cpuidvals.png
    :width: 60%

1. CPUID 指令用于获取处理器的标识和特性信息，它通过填充 EAX、EBX、ECX 和 EDX 寄存器来
   返回关于处理器家族、型号、功能和扩展信息
2. 控制寄存器（CR），如 CR0、CR3 和 CR4，用于控制处理器的操作模式和状态
3. MSR 寄存器用于获取和配置处理器的特定功能

异常
-----

异常通常是在指令导致错误时发生的事件。例如，尝试除以零就会产生一个异常。然而，有些异常，
如断点，是在其他条件下发生的。一些类型的异常可能会提供错误代码。错误代码报告了关于错误的
额外信息。下面展示了一个异常和错误代码： ::

    #PF(fault code)

这是一个某种错误代码（fault code）的页面异常（page-fault）。在某些条件下，异常可能无法
准确报告对应的错误代码，在这种情况下可能使用错误代码零，例如下面的通用保护异常： ::

    #GP(0)

执行环境
========

本章描述了 Intel 64 或 IA-32 处理器的基本执行环境，这是汇编语言程序员所看到的。它描述了
处理器如何执行指令以及如何存储和操作数据。这里描述的执行环境包括内存（地址空间）、通用数
据寄存器、段寄存器、标志寄存器和指令指针寄存器。

下面所列的是 Intel 已经移除的和将要移除的特性： ::

    特性                                                        移除年份
    Intel Memory Protection Extensions (Intel MPX)              2019
    MSR_TEST_CTRL, bit 31 (MSR address 33H)                     2019
    Hardware Lock Elision (HLE)                                 2019
    VP2INTERSECT                                                2023
    xAPIC mode                                                  2025
    Uncore PMI. IA32_DEBUGCTL MSR, bit 13 (MSR address 1D9H)    2026

操作模式
---------

IA-32 架构支持三种基本的操作模式：保护模式、实地址模式和系统管理模式。操作模式决定了可以
访问哪些指令和架构特性：

1. 保护模式（Protected mode） — 这是处理器的原生状态。保护模式的能力之一是能够直接在受
   保护的多任务环境中执行实地址模式 8086 软件。这个特性称为虚拟 8086 模式（virtual-8086
   mode），尽管它实际上并不是一个处理器模式。虚拟 8086 模式实际上是可以为任何任务启用的
   保护模式属性。

2. 实地址模式（Real-address mode） — 这种模式实现了 Intel 8086 处理器的编程环境，并带
   有扩展（例如，能够切换到保护模式或系统管理模式）。处理器在上电或复位后进入实地址模式。

3. 系统管理模式 (System management mode, SSM) — 这种模式为操作系统或执行体提供了一个
   透明机制，用于实现平台特定功能，如电源管理和系统安全。当外部 SMM 中断引脚（SMI#）被
   激活或从高级可编程中断控制器（APIC）接收到 SMI 时，处理器进入 SMM。

   在 SMM 中，处理器切换到一个单独的地址空间，同时保存当前运行程序或任务的基本上下文。然
   后可以透明地执行特定于 SMM 的代码。从 SMM 返回后，处理器恢复到系统管理中断之前的状态。
   SMM 随着 Intel386 SL 和 Intel486 SL 处理器的推出而引入，并随着 Pentium 处理器家族
   成为 IA-32 的标准特性。

Intel 64 架构增加了 IA-32e 模式。IA-32e 模式有两个子模式，分别是：

1. 兼容模式（IA-32e 的子模式） — 兼容模式允许大多数传统的 16 位和 32 位应用程序在 64
   位操作系统下无需重新编译即可运行。为简洁起见，在 IA-32 架构中，兼容子模式被称为兼容
   模式。兼容模式的执行环境与下一章节中描述的相同。兼容模式还支持 64 位和保护模式下支持
   的所有特权级别。在虚拟 8086 模式下运行或使用硬件任务管理的传统应用程序将无法在此模式
   下工作。

   操作系统（OS）可以基于一个代码段启用兼容模式。这意味着一个 64 位操作系统可以支持 64
   位应用程序在 64 位模式下运行，并且同时支持传统的 32 位应用程序（未重新编译为 64 位）
   在兼容模式下运行。

   兼容模式类似于 32 位保护模式。应用程序只能访问前 4 GB 的线性地址空间。兼容模式使用
   16 位和 32 位地址和操作数大小。像保护模式一样，这种模式允许应用程序通过 PAE（物理地
   址扩展）访问超过 4 GB 的物理内存。

2. 64 位模式（IA-32e 的子模式） — 这种模式使 64 位操作系统能够运行编写为访问 64 位线性
   地址空间的应用程序。为简洁起见，在 IA-32 架构中，64 位子模式被称为 64 位模式。

   64 位模式将通用寄存器和 SIMD 扩展寄存器的数量从 8 个扩展到 16 个。通用寄存器扩展到
   64 位。该模式还引入了一个新的操作码前缀（REX）以访问寄存器扩展。

   64 位模式由操作系统基于代码段启用。其默认地址大小为 64 位，其默认操作数大小为 32 位。
   可以在逐条指令上使用 REX 操作码前缀以及结合操作数大小前缀来修改默认的操作数大小。

   REX 前缀允许在 64 位模式下指定 64 位操作数。通过使用这种机制，许多现有指令可以得到提
   升，允许使用 64 位寄存器和 64 位地址。

环境概览
---------

在 IA-32 处理器上运行的任何程序或任务都被赋予了一组资源，用于执行指令以及存储代码、数据
和状态信息。这些资源构成了 IA-32 处理器的基本执行环境。

Intel 64 处理器支持 IA-32 处理器的基本执行环境，并在 IA-32e 模式下提供了一个类似的环
境，可以执行 64 位程序（64 位子模式）和 32 位程序（兼容子模式）。基本执行环境由运行在处
理器上的应用程序和操作系统或执行体共同使用。

* 地址空间 — 在 IA-32 处理器上运行的任何任务或程序都可以寻址高达 4 GB（2^32 字节）的线
  性地址空间和高达 64 GB（2^36 字节）的物理地址空间。有关寻址超过 4 GB 地址空间的更多
  信息，参见保护模式下的扩展物理寻址部分的内容。

* 基本程序执行寄存器 — 八个通用寄存器、六个段寄存器、EFLAGS 寄存器和 EIP（指令指针）寄
  存器构成了执行一组通用指令的基本执行环境。这些指令执行基本的整数算术运算（字节、字和双
  字整数）、处理程序流程控制、操作位和字节流以及寻址内存。有关这些寄存器的更多信息，参见
  基本程序执行寄存器部分的内容。

* x87 FPU 寄存器 — 八个 x87 FPU 数据寄存器、x87 FPU 控制寄存器、状态寄存器、x87 FPU
  指令指针寄存器、x87 FPU 操作数（数据）指针寄存器、x87 FPU 标记寄存器和 x87 FPU 操作
  码寄存器提供了一个执行环境，用于操作单精度、双精度和双扩展精度浮点值、字整数、双字整数、
  四字整数和二进制编码的十进制（BCD）值。有关这些寄存器的更多信息，参见 x87 FPU 执行环
  境部分的内容。

* MMX 寄存器 — 八个 MMX 寄存器支持在 64 位打包的字节、字和双字整数上执行单指令多数据
  （SIMD）操作。有关这些寄存器的更多信息，参见 MMX 技术编程环境部分的内容。

* XMM 寄存器 — 八个 XMM 数据寄存器和 MXCSR 寄存器支持在 128 位打包的单精度和双精度浮点
  值以及 128 位打包的字节、字、双字和四字整数上执行 SIMD 操作。有关这些寄存器的更多信息，
  参见 Intel SSE 编程环境部分的内容。

* YMM 寄存器 — YMM 数据寄存器支持在 256 位打包的单精度和双精度浮点值以及 256 位打包的
  字节、字、双字和四字整数上执行 256 位 SIMD 操作。

* 边界寄存器 — 每个 BND0-BND3 寄存器存储与内存缓冲区指针相关联的下限和上限（各 64 位）。
  它们支持执行 Intel MPX 指令。

* BNDCFGU 和 BNDSTATUS — BNDCFGU 配置用户模式 MPX 操作的边界检查。BNDSTATUS 提供了由
  MPX 操作引起的 #BR 的额外信息。

* 程序栈 — 为了支持过程或子程序调用以及在过程或子程序之间传递参数，执行环境包括了栈和栈
  管理资源。栈位于内存中，有关栈结构的更多信息，请参见过程调用中的栈部分。

除了基本执行环境中提供的资源外，IA-32 架构还将以下资源作为其系统级架构的一部分提供。它
们为操作系统和系统开发软件提供了扩展支持。除了 I/O 端口外，系统资源在第三卷中有详细描述。

* I/O 端口 — IA-32 架构支持数据传输到输入/输出（I/O）端口。参见本卷输入/输出部分。

* 控制寄存器 — 五个控制寄存器（CR0 到 CR4）决定了处理器的操作模式和当前执行任务的特征。
  参见第三卷中系统架构概览部分。

* 内存管理寄存器 — GDTR、IDTR、任务寄存器和 LDTR 指定了在保护模式内存管理中使用的数据
  结构的位置。参见第三卷中系统架构概览部分。

* 调试寄存器 — 调试寄存器（DR0 到 DR7）控制和监控处理器的调试操作。参见第三卷。

* 内存类型范围寄存器 (MTRRs) — MTRRs 用于给内存区域配置内存类型。参见第三卷中关于 MTRRs
  的部分。

* MSR 寄存器 — 处理器提供了各种 MSR 寄存器，用于控制和报告处理器性能。几乎所有 MSRs 都
  处理系统相关功能，并且对应用程序不可访问。一个例外是时间戳计数器。MSRs 描述在第四卷。

* 机器检查寄存器 — 机器检查寄存器由一组控制、状态和错误报告 MSR 寄存器组成，用于检测和
  报告硬件（机器）错误。参见第三卷机器检查架构部分。

* 性能监控计数器 — 性能监控计数器允许监控处理器性能事件。参见第三卷性能监控部分。

以上介绍的32位执行环境资源如下图：

.. image:: image/32bitenv.png
    :width: 60%

**64位执行环境**

在 64 位模式下，执行环境与上述描述的类似，其中不同的部分描述如下：

* 地址空间 — 在 IA-32 处理器上以 64 位模式运行的任务或程序可以寻址高达 2^64 字节的线性
  地址空间和高达 2^52 字节的物理地址空间。软件可以通过 CPUID 查询处理器支持的物理地址大
  小。

* 基本程序执行寄存器 — 可用的通用寄存器（GPRs）数量为 16 个。GPRs 为 64 位宽，支持对字
  节、字、双字和四字整数的操作。访问字节寄存器统一到最低的 8 位。指令指针寄存器变为 64
  位。EFLAGS 寄存器扩展到 64 位宽，并被称为 RFLAGS 寄存器。RFLAGS 的上 32 位保留，下
  32 位与 EFLAGS 相同。

* XMM 寄存器 — 有 16 个 XMM 数据寄存器用于 SIMD 操作。有关这些寄存器的更多信息，参见
  Intel SSE 编程环境部分。

* YMM 寄存器 — 有 16 个 YMM 数据寄存器用于 SIMD 操作。有关这些寄存器的更多信息，参见使
  用 Intel AVX, FMA 和 Intel AVX2 编程部分。

* 边界寄存器（BND）、BNDCFGU、BNDSTATUS — 参阅使用 XSAVE 管理状态和附录 E。

* 程序栈 — 栈指针大小为 64 位。栈大小不再由 SS 描述符中的位控制（与非 64 位模式不同），
  也不能通过指令前缀覆盖指针大小。

* 控制寄存器 — 控制寄存器扩展到 64 位。新增了一个控制寄存器（任务优先寄存器：CR8 或 TPR）。

* 调试寄存器 — 调试寄存器扩展到 64 位。参见第三卷调试、分支分析、TSC 和 Intel 资源导向
  技术部分。

* 描述符表寄存器 — 全局描述符表寄存器（GDTR）和中断描述符表寄存器（IDTR）扩展到 10 字
  节，以便它们可以包含完整的 64 位基地址。本地描述符表寄存器（LDTR）和任务寄存器（TR）
  也扩展以包含完整的 64 位基地址。

以上介绍的64位执行环境资源如下图：

.. image:: image/64bitenv.png
    :width: 60%

内存组织
---------

处理器在其总线上寻址的内存称为物理内存。物理内存被组织为一系列 8 位字节。每个字节都被分
配一个唯一的地址，称为物理地址。如果处理器不支持 Intel 64 架构，物理地址空间的范围从零
到最大 2^36 - 1（64 GB）。Intel 64 架构引入了物理和线性地址空间的一系列变化，这些变化
在后文中描述。

几乎所有设计用于与 IA-32 或 Intel 64 处理器一起工作的操作系统或执行体都会使用处理器的内
存管理设施来访问内存。这些设施提供了诸如分段和分页等功能，允许高效且可靠地管理内存。内存
管理在第三卷保护模式内存管理部分有详细描述。以下段落描述使用内存管理时寻址内存的基本方法。

**IA-32 内存模型**

在使用处理器的内存管理功能时，程序不会直接寻址物理内存。相反，它们使用三种内存模型之一来
访问内存：平坦（flat）、分段（segmented）或实地址模式（real address mode）：

* 平坦内存模型 — 内存对程序来说是一个单一的、连续的地址空间。这个空间称为线性地址空间。
  代码、数据和栈都包含在这个地址空间中。线性地址空间是按字节寻址的，地址从 0 到 2^32-1
  （如果不是在 64 位模式下）。线性地址空间中任何字节的地址称为线性地址。

* 分段内存模型 — 内存对程序来说是一个由多个独立地址空间组成的组，称为段。代码、数据和栈
  通常包含在不同的段中。要寻址段中的一个字节，程序操作一个逻辑地址。这包括一个段选择器和
  一个偏移量（逻辑地址通常被称为远指针）。段选择器标识要访问的段，偏移量标识段地址空间中
  的一个字节。在 IA-32 处理器上运行的程序可以寻址多达 16,383 个不同大小和类型的段，每个
  段可以有 2^32 字节。

  在内部，为系统定义的所有段都被映射到处理器的线性地址空间中。因此，要访问内存位置，处理
  器将每个逻辑地址转换为线性地址，这种转换对应用程序是透明的。使用分段内存的主要原因是提
  高程序和系统的可靠性。例如，将程序的栈放置在单独的段中可以防止栈扩展到代码或数据空间，
  并覆盖相应的指令或数据。

* 实地址模式内存模型 — 这是 Intel 8086 处理器的内存模型。它被支持只是为了与现存的只被编
  写用于 Intel 8086 处理器运行的程序兼容。实地址模式使用一种特定的分段内存实现，其中程
  序和操作系统或执行体的线性地址空间由最多 64 KBytes 大小的段数组组成。实地址模式中线性
  地址空间的最大大小是 2^20 字节。更多信息，请参见第三卷 8086 仿真部分。

三种内存管理模型如下图：

.. image:: image/mmmodel.png
    :width: 60%

**分页和虚拟内存**

在使用平坦或分段内存模型时，线性地址空间要么直接映射到处理器的物理地址空间，要么通过分页
映射。当使用直接映射（分页禁用）时，每个线性地址与一个物理地址有一一对应的关系。线性地址
在处理器的地址线上发送时无需转换。

当使用 IA-32 架构的分页机制（分页启用）时，线性地址空间被划分为多个页面，这些页面映射到
虚拟内存。然后根据需要将虚拟内存的页面映射到物理内存中。当操作系统或执行体使用分页时，分
页机制对应用程序是透明的。应用程序所看到的只是线性地址空间。

此外，IA-32 架构的分页机制包括支持以下扩展：

* 物理地址扩展 (PAE)：用于寻址超过 4 GB 的物理地址空间。
* 页面大小扩展 (PSE)：将线性地址映射到 4 MB 的物理地址页面。

更多信息，参见第三卷保护模式内存管理部分。

**操作模式和内存模型**

当为 IA-32 或 Intel 64 处理器编写代码时，程序员需要知道处理器在执行代码时将处于哪种操作
模式以及正在使用的内存模型。操作模式和内存模型之间的关系如下：

* 保护模式 — 在保护模式下，处理器可以使用本节描述的任何内存模型（但通常，仅当处理器处于
  虚拟-8086 模式时才使用实地址模式内存模型）。使用的内存模型取决于操作系统或执行体的设
  计。当实现多任务处理时，各个任务可以使用不同的内存模型。

* 实地址模式 — 当处于实地址模式时，处理器仅支持实地址模式内存模型。

* 系统管理模式 — 当处于 SMM 时，处理器切换到一个单独的地址空间，称为系统管理 RAM（SMRAM）。
  用于在此地址空间中寻址字节的内存模型类似于实地址模式模型。有关在 SMM 中使用的内存模型
  的更多信息，参见第三卷系统管理模式。

* 兼容模式 — 需要在兼容模式下运行的软件遵守的内存模型与 32 位保护模式下相同。分段的效果
  与 32 位保护模式语义中的相同。

* 64 位模式 — 通常（但不是完全）禁用了分段，从而创建了一个平坦的 64 位线性地址空间。具
  体来说，处理器在 64 位模式下将 CS、DS、ES 和 SS 的段基址视为零（这使得线性地址等于有
  效地址）。分段和实地址模式在 64 位模式下不可用。

**32/16位地址和操作数大小**

在保护模式下，IA-32 处理器可以配置为 32 位或 16 位地址和操作数大小。使用 32 位地址和操
作数大小时，最大的线性地址或段偏移量是 FFFFFFFFH（2^32 − 1）；操作数大小通常是 8 位或
32 位。使用 16 位地址和操作数大小时，最大的线性地址或段偏移量是 FFFFH（2^16 − 1）；操
作数大小通常是 8 位或 16 位。

当使用 32 位寻址时，逻辑地址（或远指针）由 16 位段选择器和 32 位偏移量组成；当使用 16
位寻址时，地址由 16 位段选择器和 16 位偏移量组成。指令前缀允许在程序内临时覆盖默认的地址
或操作数大小。

在保护模式下运行时，当前执行的代码段的段描述符定义了默认的地址和操作数大小。段描述符是一
个系统数据结构，通常对应用程序代码不可见。汇编命令允许为程序选择默认的寻址和操作数大小，
汇编器和其他工具随后为代码段设置适当的段描述符。

在实地址模式下运行时，默认的寻址和操作数大小是 16 位。在实地址模式中可以使用地址大小覆盖
来启用 32 位寻址。然而，允许的最大 32 位线性地址仍然是 000FFFFFH（2^20 − 1）。

**保护模式下的扩展物理寻址**

从 P6 系列处理器开始，IA-32 架构支持寻址高达 64 GB（2^36 字节）的物理内存。程序或任务
不能直接在该地址空间中的地址寻址。相反，它通过虚拟内存管理机制寻址最大为 4 GB 的各个线性
地址空间，这些空间映射到 64 GB 的物理地址空间。使用这种机制，操作系统可以使程序在 64 GB
物理地址空间内切换 4 GB 线性地址空间。

使用扩展物理寻址要求处理器在保护模式下运行，并且要求操作系统提供虚拟内存管理系统。更多信
息，见第三卷使用 PAE 分页机制的 36 位物理寻址。

**64 位模式内存组织**

Intel 64 架构支持超过 64 GB 的物理地址空间。在 64 位模式下，架构支持 64 位的线性地址空
间。然而，支持 Intel 64 架构的处理器可能实现的位数少于 64 位。

在 64 位模式下，代码、数据和栈通常使用平坦的地址空间。在 64 位模式下（如果没有覆盖地址大
小），有效地址计算的大小是 64 位。一个有效地址计算使用 64 位基址和索引寄存器，并将符号位
扩展到 64 位。

在 64 位模式的平坦地址空间中，线性地址等于有效地址，因为基址为零。如果使用非零基址的 FS
或 GS 段，则此规则不适用。在 64 位模式下，有效地址在加上完整的 64 位段基址之前被截断（例
如 LEA 指令）。无论 64 位模式中的寻址方式如何，基址永远不会被截断。

指令指针扩展到 64 位以支持 64 位代码偏移量。64 位指令指针称为 RIP。下表展示了 RIP、EIP
和 IP 之间的关系。 ::

                    比特63~32   比特31~16   比特15~0
    16位指令指针            不被修改         IP
    32位指令指针     零扩展      EIP
    64位指令指针     RIP

通常，在 64 位模式下，移位和立即数不会扩展到 64 位。它们仍然限制为 32 位，并在有效地址
计算期间进行符号扩展。然而，在 64 位模式下，为 MOV 指令提供了 64 位移位和立即数的支持。

所有 16 位和 32 位地址计算在 IA-32e 模式下进行零扩展形成 64 位地址。地址计算首先被截断
到当前模式（64 位模式或兼容模式）的有效地址大小，如任何地址大小前缀限制的大小。然后，结果
被零扩展到完整的 64 位地址宽度。

由于这个原因，16 位和 32 位应用程序在兼容模式下运行时只能访问 64 位模式有效地址的低 4GB。
同样，在 64 位模式下生成的 32 位地址也只能访问 64 位模式有效地址的低 4GB。

**规范寻址**

在 64 位模式下，如果地址位 63 到微架构实现的最高有效位被设置为全 1 或全 0，则认为地址处
于规范形式。Intel 64 架构定义了一个 64 位线性地址，但实现可能支持较少位数。首个支持 Intel 64
架构的 IA-32 处理器实现支持 48 位线性地址。这意味着规范地址必须将位 63 到 48 位设置为零
或一（取决于第 47 位是零还是一）。

尽管实现可能不使用线性地址的所有 64 位，但它们应该检查位 63 到最高有效实现位以查看地址是
否处于规范形式。如果线性内存引用不处于规范形式，实现应该生成一个异常。在大多数情况下，会
生成一个通用保护异常（#GP）。然而，在显式或隐式栈引用的情况下，会生成一个栈故障（#SS）。

默认情况下，具有隐式栈引用的指令使用 SS 段寄存器，这些包括 PUSH/POP 相关指令和使用 RSP/RBP
作为基址寄存器的指令。在这些情况下，规范故障是 #SS。

如果指令使用基址寄存器 RSP/RBP 并使用段覆盖前缀指定非 SS 段，则规范故障产生 #GP（而不是
#SS）。在 64 位模式下，只有 FS 和 GS 段覆盖在此情况下适用。其他段覆盖前缀（CS、DS、ES
和 SS）被忽略。请注意，这也意味着非栈寄存器引用如果指定 SS 段将会被忽略。这样的序列仍然
会产生 #GP 规范故障（而不是 #SS）。

基本寄存器
----------

IA-32 架构提供了 16 个基本程序执行寄存器，用于通用系统和应用程序。这些寄存器可以分为以
下几组：

* 通用寄存器：这八个寄存器可用于存储操作数和指针
* 段寄存器：这六个寄存器用于段选择
* EFLAGS 寄存器（程序状态和控制）：EFLAGS 寄存器报告正在执行的程序的状态，并允许有限的
  （应用程序级别）对处理器的控制
* EIP 寄存器（指令指针）：EIP 寄存器是一个 32 位指针指向下一条要执行的指令 

**通用寄存器**

32 位通用寄存器 EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP 用于保存以下内容：

* 逻辑和算术操作的操作数
* 地址计算的操作数
* 内存指针

尽管所有这些寄存器都可用于操作数、结果和指针的通用存储，但在涉及 ESP 寄存器时应谨慎。ESP
寄存器保存栈指针，通常不应该用于其他目的。许多指令指定特定的寄存器来保存操作数。例如，字
符串指令使用 ECX、ESI 和 EDI 寄存器的内容作为操作数。当使用分段内存模型时，一些指令假设
某些寄存器中的指针是相对于特定段的。例如，一些指令假设 EBX 寄存器中的指针指向 DS 段中的
内存位置。

在本卷指令集摘要中描述了指令对通用寄存器的特殊用途，更多信息见本卷的后续章节。以下是特殊
用途汇总：

* EAX — 累加器用于操作数和结果数据
* EBX — 指针指向 DS 段中的数据
* ECX — 字符串和循环操作的计数器
* EDX — I/O 指针
* ESI — 指向 DS 寄存器指向的段中数据的指针，字符串操作的源指针
* EDI — 指向 ES 寄存器指向的段中数据的指针，字符串操作的目标指针
* ESP — 栈顶指针（位于 SS 段）
* EBP — 指向栈中数据（位于 SS 段）

通用寄存器的低 16 位直接映射到 8086 和 Intel 286 处理器中的寄存器集，并且可以使用名称
AX、BX、CX、DX、BP、SI、DI 和 SP 引用。EAX、EBX、ECX 和 EDX 寄存器的低两个字节可以通
过名称 AH、BH、CH 和 DH（高字节）以及 AL、BL、CL 和 DL（低字节）引用。

**64位模式的通用寄存器**

在 64 位模式下，有 16 个通用寄存器，并且默认操作数大小是 32 位。然而，通用寄存器能够处
理 32 位或 64 位操作数。如果指定了 32 位操作数大小：EAX、EBX、ECX、EDX、EDI、ESI、EBP、
ESP、R8D ~ R15D 都是可用的。如果指定了 64 位操作数大小：RAX、RBX、RCX、RDX、RDI、RSI、
RBP、RSP、R8 ~ R15 都是可用的。R8D ~ R15D 和 R8 ~ R15 表示八个新的通用寄存器。

所有这些寄存器都可以在字节、字、双字和四字级别上被访问。使用 REX 前缀来生成 64 位操作数
大小或引用寄存器 R8 ~ R15。 ::

    寄存器类型  不用REX                          使用REX
    字节寄存器  AL BL CL DL AH BH CH DH          AL BL CL DL DIL SIL BPL SPL R8B ~ R15B
    字长寄存器  AX BX CX DX DI SI BP SP          AX BX CX DX DI SI BP SP R8W ~ R15W
    双字寄存器  EAX EBX ECX EDX EDI ESI EBP ESP  EAX EBX ECX EDX EDI ESI EBP ESP R8D ~ R15D
    四字寄存器  无                               RAX RBX RCX RDX RDI RSI RBP RSP R8 ~ R15

仅在 64 位模式下可用的寄存器（R8 ~ R15 和 XMM8 ~ XMM15）在从 64 位模式切换到兼容模式
然后返回到 64 位模式时会被保护。然而，从 64 位模式通过兼容模式到传统或实模式然后通过兼容
模式返回到 64 位模式后，R8 ~ R15 和 XMM8 ~ XMM15 的值是未定义的。

在 64 位模式下，对字节寄存器的访问有限制。指令不能同时引用传统的高字节（例如 AH、BH、CH、
DH）和一个新的字节寄存器（例如 RAX 寄存器的低字节）。然而，指令可以同时引用传统的低字节
（例如 AL、BL、CL 或 DL）和新的字节寄存器（例如 R8 寄存器的低字节或 RBP）。架构通过更改
使用 REX 前缀的指令中的高字节引用（AH、BH、CH、DH）为低字节引用（BPL、SPL、DIL、SIL）
来强制执行此限制。

当处于 64 位模式时，操作数大小决定了目标通用寄存器中有效位数的数量：

* 64 位操作数在目标通用寄存器中生成一个 64 位结果
* 32 位操作数在目标通用寄存器中生成一个 32 位结果，零扩展到 64 位结果
* 8 位和 16 位操作数生成一个 8 位或 16 位结果，目标通用寄存器的上 56 位或 48 位（分别）
  不会被操作修改，如果 8 位或 16 位操作的结果用于 64 位地址计算，明确地将寄存器符号扩展
  到完整的 64 位

由于在 32 位模式下 64 位通用寄存器的上 32 位是未定义的，因此在从 64 位模式切换到 32 位
模式（到保护模式或兼容模式）时，任何通用寄存器的上 32 位不会被保留。软件不应依赖这些位在
64 位到 32 位模式切换后保持值。

**段寄存器**

段寄存器（CS、DS、SS、ES、FS 和 GS）保存 16 位的段选择器。段选择器是一种特殊的指针，用
于标识内存中的一个段。要访问内存中的特定段，必须在相应的段寄存器中放置该段的段选择器。编
写应用程序代码时，程序员通常使用汇编命令和符号来创建段选择器。然后，汇编器和其他工具会创
建与这些指令和符号相关联的实际段选择器值。如果编写系统代码，程序员可能需要直接创建段选择
器。更多信息，参见第三卷保护模式内存管理。

段寄存器的使用方式取决于操作系统或执行体使用的内存管理模型类型。当使用平坦（未分段）内存
模型时，段寄存器被加载的段选择器指向重叠的分段，每个重叠段都从线性地址空间的地址 0 开始。
这些重叠的段组成了程序的线性地址空间。通常定义两个重叠的段：一个用于代码，另一个用于数据
和栈。CS 段寄存器指向代码段，所有其他段寄存器指向数据和栈段。以下是平坦内存模型下的段寄
存器的使用：

.. image:: image/flatmodesr.png
    :width: 60%

当使用分段内存模型时，通常每个段寄存器都加载有不同的段选择器，以便每个段寄存器指向线性地
址空间中的不同段。因此在任何时间，程序都可以访问线性地址空间中的六个段。要访问段寄存器未
指向的段，程序必须先将要访问的段的段选择器加载到段寄存器中。以下是分段内存模型下的段寄存
器的使用：

.. image:: image/segmodesr.png
    :width: 60%

每个段寄存器都与三种存储类型之一相关：代码、数据或栈。例如，CS 寄存器包含代码段的段选择
器，其中存储了正在执行的指令。处理器使用 CS 寄存器中的段选择器和 EIP 寄存器的内容组成的
逻辑地址从代码段中获取指令。EIP 寄存器包含要执行的下一条指令在代码段内的偏移量。CS 寄存
器不能被应用程序显式加载。相反，它是由改变程序控制的指令或内部处理器操作隐式加载的（例如
过程调用、中断处理或任务切换）。

DS、ES、FS 和 GS 寄存器指向四个数据段。四个数据段的可用性允许高效且安全地访问不同类型的
数据结构。例如，可以创建四个单独的数据段：一个用于当前模块的数据结构，另一个用于从更高级
模块导出的数据，第三个用于动态创建的数据结构，第四个用于与其他程序共享的数据。要访问其他
数据段，应用程序必须根据需要将这些段的段选择器加载到 DS、ES、FS 和 GS 寄存器中。

SS 寄存器包含栈段的段选择器，其中存储了当前正在执行的程序、任务或处理程序的过程栈。所有
栈操作都使用 SS 寄存器来查找栈段。与 CS 寄存器不同，SS 寄存器可以显式加载，这允许应用程
序设置多个栈并在它们之间切换。

四个段寄存器 CS、DS、SS、ES 与 Intel 8086 和 Intel 286 处理器中的段寄存器相同，FS 和
GS 寄存器是随着 Intel386 系列处理器引入 IA-32 架构的。

**64位模式的段寄存器**

在 64 位模式下，CS（代码段）、DS（数据段）、ES（附加段）、SS（堆栈段）被视为每个段基址
为 0，不管相关段描述符基址的值如何。这为代码、数据和栈创建了一个平坦的地址空间。FS 和
GS 寄存器是例外。这两个段寄存器可以用作线性地址计算中的额外基址寄存器（对本地数据和某些
操作系统数据结构的寻址）。

尽管通常禁用了分段，但加载段寄存器可能还是会导致处理器执行段访问的辅助操作。在这些活动中，
启用的处理器仍将对加载的值执行大多数传统检查（即使这些检查在 64 位模式下不适用）。这样的
检查是必要的，因为在 64 位模式下加载的段寄存器可能被在兼容模式下运行的应用程序使用。

在 64 位模式下，CS、DS、ES、SS、FS 和 GS 的极限检查被禁用。这意味着处理器不会对这些段寄
存器的值进行限制范围检查，这些检查在传统的实模式或保护模式中用于确保段内偏移量不会超出段
的界限。

**EFLAGS寄存器**


**指令指针**


操作数大小
-----------

操作数寻址
-----------
