NOP
-----

空指令： ::

    操作码              指令             操作数  模式    简要描述
    NP 90               NOP                 ZO  V/V     单字节空指令
    NP 0F 1F /0         NOP r/m16           M   V/V     多字节空指令
    NP 0F 1F /0         NOP r/m32           M   V/V     多字节空指令

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无
    M       ModRM:r/m (r)       无              无          无

    NOP 空操作
    nop                   1001 0000
    reg         0000 1111 0001 1111 : 11 000 reg
    mem         0000 1111 0001 1111 : mm 000 r/m

    NOP (90H)

    NOP (1FH) mm 000 r/m
         Ev

    * Ev 操作数大小根据属性决定，位于r/m字段，是寄存器或内存数据
    * 1 字节：90
    * 2 字节：66 90
    * 3 字节：0F 1F 00                      00_000_000 DWORD ptr [eax]
    * 4 字节：0F 1F 40 00                   01_000_000 DWORD ptr [eax + 00H]
    * 5 字节：0F 1F 44 00 00                01_000_100 DWORD ptr [eax + eax*1 + 00H]
    * 6 字节：66 0F 1F 44 00 00             01_000_100 DWORD ptr [eax + eax*1 + 00H]
    * 7 字节：0F 1F 80 00 00 00 00          10_000_000 DWORD ptr [eax + 00000000H]
    * 8 字节：0F 1F 84 00 00 00 00 00       10_000_100 DWORD ptr [eax + eax*1 + 00000000H]
    * 9 字节：66 0F 1F 84 00 00 00 00 00    10_000_100 DWORD ptr [eax + eax*1 + 00000000H]

**操作**

单字节 NOP 相当于 XCHG (E)AX,(E)AX 指令。多字节 NOP 仅当 CPUID.01H.EAX[Bytes 11:8]
为 0110B 或 1111B 才支持。空指令除了 EIP/RIP 寄存器，对其他多不产生影响。

**标志位**

不影响标志位。

UD
----

未定义指令： ::

    操作码              指令             操作数  模式    简要描述
    0F FF /r            UD0* r32, r/m32     RM  V/V     抛出非法操作码异常
    0F B9 /r            UD1 r32, r/m32      RM  V/V     抛出非法操作码异常
    0F 0B               UD2                 ZO  V/V     抛出非法操作码异常

    * 某些处理器在没有 ModR/M 字节的情况下解码 UD0 指令。因此，当带有 ModR/M 字节的指
      令（以及任何隐含的字节）跨越页面或段边界时，这些处理器会在指令预取时引发无效操作码
      异常，而不是引发故障（fault）。

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无
    RM      ModRM:reg (r)       ModRM:r/m (r)   无          无

    UD0 (FFH) mm reg r/m

    UD1↑1B (B9H) mm 000 r/m

    UD2↑1B (0BH)

    * 1B 故意尝试生成无效操作码异常（#UD）时，使用 0F0B 操作码（UD2 指令）、0FB9 操作
      码（UD1 指令）或 0FFF 操作码（UD0 指令）

**操作**

产生 #UD 非法操作码异常。

**标志位**

不影响标志位。

SYSCALL
--------

调用内核服务： ::

    操作码              指令             操作数  模式    简要描述
    0F 05               SYSCALL             ZO  V/Inv.  快速调用特权级别0的系统过程

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无

**操作**

SYSCALL 指令在特权级别0调用操作系统系统调用处理程序。它将下一条指令的地址保存到 RCX 寄
存器后，通过从 IA32_LSTAR MSR 加载 RIP 来实现。WRMSR 指令确保IA32_LSTAR MSR 始终包含
一个规范地址。

SYSCALL 会保护 RFLAGS 到 R11，并使用 IA32_FMASK MSR（MSR 地址 C0000084H）对 RFLAGS
进行掩码操作；具体来说，处理器清除 RFLAGS 中对应于 IA32_FMASK MSR 中置位的每个位。

SYSCALL 使用 IA32_STAR MSR 中的 47:32 衍生的值加载 CS 和 SS 选择器。然而，CS 和 SS
描述符缓存不是从这些选择器指定的描述符（GDT 或 LDT）中加载的。相反，描述符缓存被加载固
定值。操作系统软件有责任确保这些选择器引用的描述符（在 GDT 或 LDT 中）对应加载到描述符
缓存中的固定值；SYSCALL 指令不确保这种对应关系。

SYSCALL 指令不保存堆栈指针（RSP）。如果操作系统系统调用处理程序将更改堆栈指针，则软件有
责任保存堆栈指针先前的值。这可以在执行 SYSCALL 之前完成，软件在 SYSCALL 之后（SYSRET
之后）使用指令恢复堆栈指针。或者，操作系统系统调用处理程序可以在执行 SYSRET 之前保存堆栈
指针并恢复它。

**标志位**

影响所有标志位。

INT
-----

中断指令： ::

    操作码              指令             操作数  模式    简要描述
    CC                  INT3                ZO  V/V     产生一个 breakpoint trap
    CD ib               INT imm8            I   V/V     产生一个软中断
    CE                  INTO                ZO  Inv./V  如果 OF=1 生成一个 overflow trap
    F1                  INT1                ZO  V/V     产生一个 debug trap

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无
    I       imm8                无              无          无

    INT3 (CCH)

    INT (CDH)
         Ib

    INTO↑i64 (CEH)

    INT1 (F1H)

    * Ib 操作数大小是单字节，位于立即数字段
    * i64 该指令在 64 位模式下无效或无法编码

**操作**

INT n 指令生成对由目标操作数指定的中断或异常处理程序的调用，参考卷 1 第 6 章中断和异常。
目标操作数指定了一个从 0 到 255 的向量，编码为一个 8 位无符号值。每个向量提供了一个索引
到 IDT（中断描述符表）中的门描述符。前 32 个向量被 Intel 保留用于系统使用。这些向量中的
一些用于内部生成的异常。INT n 指令是执行软件生成的对中断处理程序调用的通用助记符。

INT3 指令使用一个字节操作码（CC），旨在调用调试异常处理程序，并生成断点异常（#BP）。这
种单字节形式很有用，因为它可以替换任何想要设置断点的指令的第一个字节，包括其他单字节指令，
而不会覆盖其他指令。

INTO 指令是调用溢出异常（#OF），异常 4 的特殊助记符。溢出中断检查 EFLAGS 寄存器中的 OF
标志，并在 OF 标志设置为 1 时调用溢出中断处理程序。INTO 指令不能在 64 位模式下使用。

INT1 指令也使用一个字节的操作码（F1），并生成一个调试异常（#DB），而不在 DR6 设置任何位。
硬件供应商可能使用 INT1 指令进行硬件调试，因此 Intel 建议软件供应商改用 INT3 指令作为
软件断点。

**标志位**

EFLAGS 寄存器被推入栈中。在执行 INT 指令时，根据处理器的运行模式，IF TF NT AC RF VM
可能会被清除。如果中断使用了任务门，任何标志都可能被设置或清除，由新任务 TSS 中的 EFLAGS
映像控制。

STI
-----

中断使能： ::

    操作码              指令             操作数  模式    简要描述
    FB                  STI                 ZO  V/V     下条指令结束时使能外部、可屏蔽中断

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无

    STI (FBH)

**操作**

在大多数情况下，STI 指令会设置 EFLAGS 寄存器中的中断标志（IF）。这允许处理器响应可屏蔽
的硬件中断。如果 IF = 0，则在执行 STI 指令后的指令边界上，可屏蔽的硬件中断仍然被禁止。
这种指令的延迟效果是为了允许在从过程或子程序返回之前启用中断。例如，如果 STI 指令后跟一
个 RET 指令，那么允许 RET 指令在外部中断被识别之前执行。如果在执行 STI 后立即执行 CLI
指令，则不能识别任何中断。在另一个事件（例如，异常）交付后或下一个指令执行后，这种禁止结
束。

IF 标志和 STI 与 CLI 指令不会禁止异常和不可屏蔽中断（NMIs）的生成。然而，在执行以 IF=0
开始的 STI 指令后的指令边界上，NMIs（和系统管理中断）可能会被禁止。

**标志位**

IF 或 VIP 会设置成 1，其他标志位不影响。

CLI
-----

中断屏蔽： ::

    操作码              指令             操作数  模式    简要描述
    FA                  CLI                 ZO  V/V     中断标志清除后中断就被关闭

    类型    操作数1             操作数2         操作数3     操作数4
    ZO      无                  无              无          无

    CLI (FAH)

**操作**

在大多数情况下，CLI 指令会清除 EFLAGS 寄存器中的 IF 标志，其他标志不受影响。清除 IF 标
志会导致处理器忽略可屏蔽的外部中断。IF 标志以及 CLI 和 STI 指令对异常和不可屏蔽中断（NMI）
的生成没有影响。

**标志位**

IF 或 VIP 会设置成 0，其他标志位不影响。

RDRAND 读取随机数
-----------------

RDSEED 读取种子
---------------

STC 设置进位
------------

CLC 清除进位
------------

CMC 取反进位
------------

STD 置位方向
------------

CLD 清位方向
------------

LAHF 加载到AH
-------------

SAHF 从AH加载
-------------

CPUID
------

XSAVE
------

XRSTOR
-------

XGETBV
-------

XLAT 表查找
------------

PREFETCHW
----------

PREFETCHWT1
------------

CLFLUSH
--------

CLFLUSHOPT
-----------

INTO 溢出时中断
---------------

BOUND 检测值范围
----------------

IRET 中断返回
-------------

IN 输入到寄存器
---------------

INS 输入到字符串
----------------

OUT 从寄存器输出
----------------

OUTS 从字符串输出
-----------------
