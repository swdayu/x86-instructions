操作码映射表
============

在 IA-32 和 Intel 64 架构中，操作码映射表用于解释指令代码。这些指令被分为不同的编码组：

* 1 字节、2 字节和 3 字节操作码编码：用于编码整数、系统、MMX 技术、SSE/SSE2/SSE3/
  SSE3/SSE4 和 VMX 指令。这些指令的映射在表-2到表-6中给出。
* 转义操作码（格式为：转义字符、操作码、ModR/M 字节）：用于浮点指令。这些指令的映射在
  表-7到表-22中提供。

这里列出了指令的操作码（包括所需的指令前缀和相关 ModR/M 字节中的操作码扩展）。表格中的
空白单元格表示保留或未定义的操作码。标有 “Reserved-NOP” 的单元格也是保留的，但在某些处
理器上可能表现为 NOP（无操作）。软件不应使用对应于空白单元格或标有 “Reserved-NOP” 的操
作码，也不应依赖这些操作码当前的行为。

操作码映射表按操作码字节的高 4 位和低 4 位的十六进制值组织。对于 1 字节编码（表-2）：使
用操作码的四个高阶位作为操作码表的行索引；使用四个低阶位作为表的列索引。对于以 0FH 开始
的 2 字节操作码（表-3）：跳过任何指令前缀，0FH 字节（0FH 之前可能有 66H、F2H 或 F3H）；
使用下一个操作码字节的高 4 位和低 4 位值来索引表的行和列。类似地，对于以 0F38H 或 0F3AH
开始的 3 字节操作码（表-4）：跳过任何指令前缀，0F38H 或 0F3AH；使用第三个操作码字节的高
4 位和低 4 位值来索引表的行和列。

当 ModR/M 字节提供操作码扩展时，这些信息会限定操作码的执行。有关 ModR/M 字节中操作码扩
展如何修改表-2和表-3中的操作码映射的信息，请参见操作码扩展部分。

浮点指令的转义（ESC）操作码列表在每页的顶部标出操作码的八个高阶位。如果对应的 ModR/M 字
节在 00H-BFH 范围内，顶行中的 bit3~5 以及 ModR/M 的 reg 位确定操作码。超出 00H-BFH 范
围的 ModR/M 字节由每页底部的两个表映射。

缩写词说明
-----------

操作数通常由两个字符标识，形式为 Zz。第一个字符是大写字母，指定寻址方式；第二个字符是小
写字母，指定操作数的类型。

下面这些缩写用于在文档中描述寻址方式：

**A**
    直接地址：指令中没有 ModR/M 字节；操作数的地址编码在指令中。不能应用基寄存器、索引
    寄存器或缩放因子。例如远跳转 JMP (EA)。
**B**
    VEX 前缀的 VEX.vvvv 字段选择一个通用寄存器。
**C**
    ModR/M 字节的 reg 字段选择一个控制寄存器。例如 MOV (0F20, 0F22)。
**D**
    ModR/M 字节的 reg 字段选择一个调试寄存器。例如 MOV (0F21, 0F23)。
**E**
    操作码后跟一个 ModR/M 字节，指定操作数。操作数可以是通用寄存器或内存地址。如果是内
    存地址，地址由段寄存器和以下值计算得出：基寄存器、索引寄存器、缩放因子、偏移。
**F**
    EFLAGS/RFLAGS 寄存器。
**G**
    ModR/M 字节的 reg 字段选择一个通用寄存器。例如 AX (000)。
**H**
    VEX 前缀的 VEX.vvvv 字段选择一个 128 位 XMM 寄存器或 256 位 YMM 寄存器，由操作数
    类型决定。对于传统的 SSE 编码，这个操作数不存在，将指令变为破坏性形式。
**I**
    立即数数据：操作数值编码在指令的后续字节中。
**J**
    指令包含一个相对偏移量，要加到指令指针寄存器上。例如 JMP (0E9)，LOOP。
**L**
    8位立即数的高 4 位选择一个 128 位 XMM 寄存器或 256 位 YMM 寄存器，由操作数类型决
    定（在32位模式中忽略最高位）。
**M**
    ModR/M 字节只能引用内存。例如 BOUND，LES，LDS，LSS，LFS，LGS，CMPXCHG8B。
**N**
    ModR/M 字节的 R/M 字段选择一个打包的四字（quadword），MMX 技术寄存器。
**O**
    指令没有 ModR/M 字节。操作数的偏移量编码为指令中的一个字或双字（取决于地址大小属性）。
    不能应用基寄存器、索引寄存器或缩放因子。例如 MOV (A0–A3)。
**P**
    ModR/M 字节的 reg 字段选择一个打包的四字 MMX 技术寄存器。
**Q**
    操作码后跟一个 ModR/M 字节，指定操作数。操作数可以是 MMX 技术寄存器或内存地址。如果
    是内存地址，地址由段寄存器和以下值计算得出：基寄存器、索引寄存器、缩放因子和偏移。
**R**
    ModR/M 字节的 R/M 字段只能引用通用寄存器。例如 MOV (0F20-0F23)。
**S**
    ModR/M 字节的 reg 字段选择一个段寄存器。例如 MOV (8C, 8E)。
**U**
    ModR/M 字节的 R/M 字段选择一个 128 位 XMM 寄存器或 256 位 YMM 寄存器，由操作数类
    型决定。
**V**
    ModR/M 字节的 reg 字段选择一个 128 位 XMM 寄存器或 256 位 YMM 寄存器，由操作数类
    型决定。
**W**
    操作码后跟一个 ModR/M 字节，指定操作数。操作数可以是 128 位 XMM 寄存器、256 位 YMM
    寄存器（由操作数类型决定）或内存地址。如果是内存地址，地址由段寄存器和以下值计算得出：
    基寄存器、索引寄存器、缩放因子和偏移。
**X**
    由 DS:rSI 寄存器对寻址的内存。例如 MOVS, CMPS, OUTS, 或 LODS。
**Y**
    由 ES:rDI 寄存器对寻址的内存。例如，MOVS, CMPS, INS, STOS, 或 SCAS。

下面这些缩写用于在文档中描述操作数的类型：

**a**
    内存中的两个单字（word）操作数，或根据操作数大小属性，内存中的两个双字（dword）操作
    数（仅由BOUND指令使用）。
**b**
    字节，不考虑操作数大小属性。
**c**
    根据操作数大小属性，字节或字（word）。
**d**
    双字（doubleword），不考虑操作数大小属性。
**dq**
    双四字（double-quadword），不考虑操作数大小属性。
**p**
    根据操作数大小属性，32位、48位或80位指针。
**pd**
    128位或256位打包双精度浮点数据。
**pi**
    四字（quadword）MMX技术寄存器。例如 mm0。
**ps**
    128位或256位打包单精度浮点数据。
**q**
    四字（quadword），不考虑操作数大小属性。
**qq**
    四四字（quad-quadword，256位），不考虑操作数大小属性。
**s**
    6字节或10字节伪描述符。
**sd**
    128位双精度浮点数据的标量元素。
**ss**
    128位单精度浮点数据的标量元素。
**si**
    双字（doubleword）整数寄存器。例如 eax。
**v**
    根据操作数大小属性，字（word）、双字（doubleword）或四字（quadword）（在64位模式下）。
**w**
    字（word），不考虑操作数大小属性。
**x**
    根据操作数大小属性，dq或qq。
**y**
    根据操作数大小属性，双字（doubleword）或四字（quadword）（在64位模式下）。
**z**
    对于16位操作数大小，字（word）；对于32位或64位操作数大小，双字（doubleword）。

当操作码需要特定寄存器作为操作数时，会通过名称来标识这些寄存器（例如 AX、CL 或 ESI）。
寄存器的名称表明了它是 64 位、32 位、16 位还是 8 位宽。

当寄存器宽度取决于操作数大小属性时，使用形式为 eXX 或 rXX 的寄存器标识符。eXX 用于可能
存在 16 位或 32 位大小的情况；rXX 用于可能存在 16 位、32 位或 64 位大小的情况。例如：
eAX 表示当操作数大小属性为 16 位时使用 AX 寄存器，当操作数大小属性为 32 位时使用 EAX
寄存器。rAX 可以表示 AX、EAX 或 RAX。

当使用 REX.B 位修改操作码中 reg 字段指定的寄存器时，这一事实通过在寄存器名称中添加 “/x”
来表示额外的可能性。例如，rCX/r9 用于表示寄存器可以是 rCX 或 r9。请注意，在这种情况下，
r9 的大小由操作数大小属性决定（与 rCX 相同）。
