处理器指令格式

* `指令格式`_

  * `指令前缀`_
  * `操作码`_
  * `寻址形式说明符`_
  * `偏移量和立即数`_
  * `寻址编码`_

* `64 位格式`_

  * `编码说明`_
  * `REX 前缀字段`_
  * `地址偏移`_
  * `操作数`_
  * `RIP 相对寻址`_

* `AVX 扩展格式`_

* `指令参考说明`_

  * `操作码信息`_
  * `指令信息`_

本章描述了所有 Intel 64 和 IA-32 处理器的指令格式。保护模式、实地址模式和虚拟 8086 模
式的指令格式在第一部分介绍，IA-32e 模式及其子模式的不同内容在第二部分描述。

指令格式
=========

Intel 64 和 IA-32 架构的指令编码如下图所示格式的子集。指令由以下部分组成：

* 可选的指令前缀：可以有任意顺序的零个或多个指令前缀，用于修改指令的行为，如改变操作数大
  小或指定特殊操作，每个指令前缀为一个字节
* 主要操作码字节：最多三个字节，用于指定要执行的操作
* 寻址形式说明符：如果需要，由 ModR/M 字节组成，有时还包括 SIB（Scale-Index-Base）字节，
  因此长度为零到两个字节（ModR/M and SIB Bytes）
* 偏移量（Displacement）：如果需要，指定内存地址的偏移量，长度零、一、二、四个字节
* 立即数字段：如果需要，提供指令直接操作的数据，长度零、一、二、四个字节

.. image:: image/insformat.png
    :width: 70%

REX 前缀是可选的，但如果使用，它的后面必须紧跟操作码字段。很少一部分指令的偏移量字段和立
即数字段的长度可能为八字节。

指令前缀
---------

指令前缀被分为四组，每组都有一组允许的前缀代码。对于每条指令，只允许包含来自四组中的每个
组的一个前缀代码，但相对顺序可以是任意的。

**第1组**

锁定和重复前缀：

* LOCK 前缀 F0H
* REPNE/REPNZ 前缀 F2H，仅适用于字符串和输入/输出指令，还被用作某些指令的强制前缀
* REP 或 REPE/REPZ 前缀 F3H，仅适用于字符串和输入/输出指令，还被用作某些指令的强制前缀

边界（BND）前缀被编码为 F2H，当满足以下条件：

* CPUID.(EAX=07H, ECX=0):EBX.MPX[bit 14] 被设置
* BNDCFGU.EN 和/或 IA32_BNDCFGS.EN 被设置
* 当 F2 前缀位于近 CALL、近 RET、近 JMP、短 Jcc 或近 Jcc 指令之前（见附录 Intel 内存
  保护扩展）

**第2组**

段覆盖前缀，这些前缀用于覆盖默认段寄存器，指定内存操作应该使用的段：

* 2EH — CS 段前缀（与任何分支指令一起使用时是保留暂未定义的情况）
* 36H — SS 段覆盖前缀（与任何分支指令一起使用时保留）
* 3EH — DS 段覆盖前缀（与任何分支指令一起使用时保留）
* 26H — ES 段覆盖前缀（与任何分支指令一起使用时保留）
* 64H — FS 段覆盖前缀（与任何分支指令一起使用时保留）
* 65H — GS 段覆盖前缀（与任何分支指令一起使用时保留）

分支提示（Branch Hints），分支提示用于给处理器提供关于分支方向的非强制性建议，以优化流
水线性能：

* 2EH — 分支不采取（仅与 Jcc 指令一起使用）
* 3EH — 分支采取（仅与 Jcc 指令一起使用）

不同的微架构可能行为不同，具体细节和优化建议参考《Intel 64 和 IA-32 架构优化参考手册》。

**第3组**

操作数大小覆盖前缀：

* 66H — 用于指定操作数的大小为 16 位或 32 位，而不是默认的大小；66H 也被用作某些指令的
  强制性前缀

**第4组**

地址大小覆盖前缀：

* 67H — 用于指定内存地址的大小为 16 位或 32 位，而不是默认的大小

锁定前缀（F0H）强制执行一项操作，确保在多处理器环境中对共享内存的独占使用。有关此前缀的
描述，请参见 A-L指令集参考中的“锁定—断言LOCK#信号前缀”。

重复前缀（F2H、F3H）使指令对字符串的元素执行重复操作，仅与字符串和I/O指令（MOVS、CMPS、
SCAS、LODS、STOS、INS和OUTS）一起使用。在其他 Intel 64 或 IA-32 指令中使用重复前缀或
未定义操作码是保留的，这种使用可能导致不可预测的行为。某些指令可能使用 F2H 或 F3H 作为
强制性前缀来表达不同的功能。

分支提示前缀（2EH、3EH）允许程序在条件分支指令（Jcc）上给处理器一个提示，关于分支的最可
能的代码路径。

操作数大小覆盖前缀允许程序在 16 位和 32 位操作数大小之间切换。两种大小都可以是默认值，使
用此前缀选择非默认大小。一些 SSE2/SSE3/SSSE3/SSE4 指令和使用三个字节主操作码序列的指令
可能使用 66H 作为强制性前缀来表达不同的功能。66H 前缀的其他使用是保留的，这种使用可能会
导致不可预测的行为。

地址大小覆盖前缀（67H）允许程序在 16 位和 32 位寻址之间切换。两种大小都可以是默认值，该
前缀选择非默认大小。当指令的操作数不位于内存中时，使用此前缀和/或其他未定义的操作码是保留
的，这种使用可能会导致不可预测的行为。

操作码
-------

主要操作码长度可以是 1、2 或 3 字节，有时在 ModR/M 字节中另外编码一个 3 比特的操作码字
段。在主要操作码内部可以定义较小的字段，这些字段定义了操作的方向、偏移量的大小、寄存器编
码、条件码或符号扩展。操作码使用的编码字段取决于操作类别而各有不同。

通用和 SIMD 指令的两字节操作码格式由以下之一组成：

1. 转义操作码字节 0FH 作为主要操作码、和一个第二操作码字节
2. 强制前缀（66H、F2H 或 F3H）、转义操作码字节、和一个第二操作码字节

例如，CVTDQ2PD 由以下序列组成：F3 0F E6，第一个字节是强制性前缀。

通用和 SIMD 指令的三字节操作码格式由以下之一组成：

1. 转义操作码字节 0FH 作为主要操作码，加上两个额外的操作码字节
2. 强制性前缀（66H、F2H 或 F3H）、转义操作码字节，加上两个额外的操作码字节

例如，XMM 寄存器的 PHADDW 由以下序列组成：66 0F 38 01，第一个字节是强制性前缀。

有效的操作码表达式在附录 A 和附录 B 中定义。

寻址形式说明符
--------------

许多引用内存操作数的指令在主要操作码之后都有一个寻址形式说明符字节（称为 ModR/M 字节）。
ModR/M 字节包含三个字段的信息：

* mod 字段：与 r/m 字段结合，形成 32 个可能的值：八个寄存器和 24 种寻址模式。
* reg/opcode 字段：指定寄存器编号或另外三位操作码信息。reg/opcode 字段的目的在主要操作
  码中指定。
* r/m 字段：可以指定寄存器作为操作数，或者与 mod 字段结合以编码寻址模式。有时，mod 字段
  和 r/m 字段的某些组合用于表达某些指令的操作码信息。

某些 ModR/M 字节的编码需要第二个寻址字节（SIB 字节）。32 位寻址的基址加索引、比例加索引
形式需要 SIB 字节。SIB 字节包括以下字段：

* scale 字段：指定缩放因子。
* index 字段：指定索引寄存器的寄存器编号。
* base 字段：指定基址寄存器的寄存器编号。

有关 ModR/M 和 SIB 字节的编码，参见 `寻址编码`_ 。

偏移量和立即数
--------------

一些寻址形式包括紧跟在 ModR/M 字节之后的偏移量（如果存在 SIB 字节，则紧跟在 SIB 字节之
后）。如果需要偏移量，它可以是 1、2 或 4 字节。

如果指令指定了一个立即操作数，该操作数总是跟在任何偏移量字节之后。立即操作数可以是 1、2
或 4 字节。

寻址编码
--------

64 位格式
==========

Intel 64 架构的 IA-32e 模式，包含两个子模式：

* 兼容模式（Compatibility Mode）：允许 64 位操作系统运行大多数传统的保护模式软件，而无
  需修改。这种模式主要用于向后兼容 32 位应用程序，使它们能够在 64 位操作系统上运行。
* 64 位模式（64-Bit Mode）：允许 64 位操作系统运行为访问 64 位地址空间而编写的应用程序。
  这种模式提供了对更大内存空间的访问能力，并且支持 64 位宽的寄存器和操作数。

REX 前缀是 64 位模式下使用的指令前缀字节。它们执行以下操作：

* 指定通用寄存器（GPRs）和 SSE 寄存器：REX 前缀允许访问扩展的通用寄存器和 SSE 寄存器，
  例如使用 R8 到 R15 的寄存器。
* 指定 64 位操作数大小：REX 前缀用于指定操作数为 64 位，这在处理 64 位数据时是必要的。
* 指定扩展控制寄存器：REX 前缀还用于访问扩展的控制寄存器。

并非所有 64 位模式下的指令都需要 REX 前缀。只有当指令引用扩展寄存器或字节寄存器 SPL、
BPL、SIL、DIL 之一，或使用 64 位操作数时，才需要 REX 前缀。如果指令不需要 REX 前缀，
或者 REX 前缀没有立即前置于它需要的指令操作码字节或转义操作码字节（0FH），则 REX 前缀将
被忽略。这意味着只有一个正确放置的 REX 前缀才可以影响指令。

当 REX 前缀与包含强制性前缀的指令结合使用时，强制性前缀必须位于 REX 前缀之前，以便 REX
前缀能够立即前置于操作码或转义字节。例如，带有 REX 前缀的 CVTDQ2PD 应该在 F3 和 0F E6
之间放置 REX。其他放置方式将被忽略。带有 REX 前缀的指令仍然适用指令大小的 15 字节限制。
如下图指令前缀顺序：

.. image:: image/prefixorder.png
    :width: 70%

编码说明
--------

Intel 64 和 IA-32 指令格式根据编码中的 3 个比特位字段来指定最多三个寄存器：

1. ModR/M：ModR/M 字节中的 reg 和 r/m 字段
2. 带有 SIB 的 ModR/M：ModR/M 字节中的 reg 字段，以及 SIB（scale, index, base）字节
   中的 base 和 index 字段
3. 不带 ModR/M 的指令：操作码中的 reg 字段

在 64 位模式下，这些格式并没有改变。定义 64 位上下文中的字段所需的位通过添加 REX 前缀来
提供。

在 64 位模式下，为控制寄存器和调试寄存器提供了一些额外编码。REX.R 位用于修改 ModR/M reg
字段，当该字段编码控制寄存器或调试寄存器时。这些编码使得处理器能够寻址 CR8 ~ CR15 和
DR8 ~ DR15。在 64 位模式中定义了一个额外的控制寄存器（CR8），也称为任务优先寄存器（TPR）。

在 IA-32e 模式的首个实现中，CR9 ~ CR15 和 DR8 ~ DR15 并未实现。任何尝试访问未实现寄存
器的操作都会导致无效操作码异常（#UD）。

REX 前缀字段
------------

地址偏移
---------

在 64 位模式下，寻址使用现有的 32 位 ModR/M 和 SIB 编码。ModR/M 和 SIB 的偏移大小不会
改变，它们保持 8 位或 32 位，最后通过符号位扩展拉伸到 64 位。

在 64 位模式下，MOV 指令的直接内存偏移形式被扩展以指定一个 64 位的立即绝对地址。这个地
址被称为 moffset。指定这个 64 位内存偏移不需要前缀。对于这些 MOV 指令，内存偏移的大小遵
循地址大小默认值（在 64 位模式下为 64 位）。直接内存偏移形式的 MOV 指令如下： ::

    操作码      指令
    A0          MOV AL, moffset
    A1          MOV EAX, moffset
    A2          MOV moffset, AL
    A3          MOV moffset, EAX

操作数
-------

在 64 位模式下，立即操作数的典型大小仍然是 32 位。当操作数大小为 64 位时，处理器会在使
用之前将所有立即数符号扩展到 64 位。

对 64 位立即操作数的支持是通过扩展现有的移动（MOV reg, imm16/32）指令的语义来实现的。
这些指令（操作码 B8H 到 BFH）将 16 位或 32 位的立即数据（取决于有效操作数大小）移动到通
用寄存器（GPR）中。当有效操作数大小为 64 位时，这些指令可以用来将立即数加载到 GPR 中。
需要一个 REX 前缀来覆盖 32 位默认操作数大小到 64 位操作数大小。

例如： ::

    48 B8 8877665544332211 MOV RAX,1122334455667788H

在 64 位模式下，有两组指令默认操作数大小为 64 位（不需要 REX 前缀来指定此操作数大小）。
这些指令包括：

1. 近分支（Near branches）：这些是跳转指令，它们在代码中跳转到距离当前位置较近的位置。
   在 64 位模式下，这些分支指令的默认目标地址是 64 位的，因此不需要额外的前缀来指定操作
   数大小。
2. 除了远分支外的所有隐式引用 RSP 的指令，：这包括如 PUSH、POP、CALL 和 RET 等指令，它
   们操作栈指针 RSP。在 64 位模式下，这些指令默认使用 64 位的栈指针，因此也不需要 REX
   前缀。

RIP 相对寻址
------------

在 64 位模式下，实现了一种新的寻址形式，即 RIP 相对寻址（相对于指令指针）。有效地址是通
过将偏移添加到下一条指令的 64 位 RIP 上形成的。

在 IA-32 架构和兼容模式中，只有控制权转移指令才能使用相对于指令指针的寻址。在 64 位模式
下，使用 ModR/M 寻址的指令可以使用 RIP 相对寻址。没有 RIP 相对寻址，所有 ModR/M 模式都
相对于零寻址内存。

RIP 相对寻址允许特定的 ModR/M 模式使用带符号的 32 位偏移相对于 64 位 RIP 寻址内存。这
提供了从 RIP 起 ±2GB 的偏移范围。下图显示了 RIP 相对寻址的 ModR/M 和 SIB 编码。在当前
的 ModR/M 和 SIB 编码中，存在 32 位偏移寻址的冗余形式。有一个 ModR/M 编码，并且有多个
SIB 编码。RIP 相对寻址使用冗余形式编码。在 64 位模式下，ModR/M Disp32（32 位偏移）编码
被重新定义为 RIP+Disp32 而不是单纯的偏移。

.. image:: image/ripaddressing.png
    :width: 80%

RIP 相对寻址的 ModR/M 编码不依赖于前缀的使用。具体来说，用于选择 RIP 相对寻址的 r/m 位
字段编码 101B（用于选择 RIP 相对寻址）不受 REX 前缀的影响。例如，选择 R13（REX.B = 1,
r/m = 101B）时，mod = 00B 仍然会产生 RIP 相对寻址。REX.B 的 4 位 r/m 字段与 ModR/M
结合使用时，并没有完全解码。为了在没有偏移的情况下寻址 R13，软件必须使用零字节偏移编码
R13 + 0。

RIP 相对寻址是由 64 位模式启用的，而不是由 64 位地址大小启用的。使用地址大小前缀不会禁
用 RIP 相对寻址。地址大小前缀的作用是将计算出的有效地址截断并零扩展到 32 位。

AVX 扩展格式
============

指令参考说明
============

在指令参考手册中，对于每条指令，描述了每个操作数组合。还提供了指令及其操作数、操作说明、
指令对 EFLAGS寄存器中标志的影响、以及可能产生的异常等描述信息。

以下是指令参考信息的格式示例：

.. image:: image/insinfofmt.png
    :width: 90%

其中包括六部分信息：

1. 操作码（Opcode）
2. 指令（Instruction）
3. 操作数编码（Op/En）
4. 64/32位模式（64/32-bit Mode）
5. CPUID特性标志
6. 描述

操作数编码的示例如下：

.. image:: image/operandencode.png
    :width: 90%

操作码信息
----------

在指令参考手册中，“操作码（Opcode）” 列显示了每种形式的指令产生的对象代码。代码尽可能地
以十六进制字节的形式给出，与它们在内存中出现的顺序相同。而非十六进制字节条目的定义如下：

**NP**
    表示不允许在指令中使用 66/F2/F3 前缀（超出指令操作码已经包含的部分）。如果这样使用
    将导致无效操作码异常（#UD）或编码为不同指令。
**NFx**
    表示不允许在指令中使用 F2/F3 前缀（超出指令操作码已经包含的部分）。如果这样使用将导
    致无效操作码异常（#UD）或编码为不同指令。
**REX.W**
    表示使用影响操作数大小或指令语义的 REX 前缀。REX 前缀和其他可选/强制性指令前缀的顺
    序在前面已讨论。注意，提升传统指令到 64 位行为的 REX 前缀在操作码列中没有明确列出。
**/digit**
    0 到 7 之间的数字表示指令的 ModR/M 字节仅使用 r/m 操作数。reg 字段包含的数字为指令
    操作码提供了扩展。
**/r**
    表示指令的 ModR/M 字节包含寄存器操作数和 r/m 操作数。
**cb, cw, cd, cp, co, ct**
    1 字节（cb）、2 字节（cw）、4 字节（cd）、6 字节（cp）、8 字节（co）或 10 字节
    （ct）值跟在操作码之后。这个值用于指定代码偏移，并可能为代码段寄存器指定一个新值。
**ib, iw, id, io**
    1 字节（ib）、2 字节（iw）、4 字节（id）或 8 字节（io）的立即操作数跟随操作码、ModR/M
    字节或 SIB 字节。操作码决定操作数是否为有符号值。所有字、双字和四字都以低序字节优先
    给出。
**+rb, +rw, +rd, +ro**
    表示操作码字节的低 3 位被用来编码寄存器操作数，而不使用 ModR/M 字节。指令列出了带有
    低 3 位为 000b 的操作码字节的对应十六进制值。在非 64 位模式下，从 0 到 7 的寄存器
    代码被加到操作码字节的十六进制值上。在 64 位模式下，表示 REX.b 和操作码[2:0] 字段
    的四位字段编码指令的寄存器操作数。"+ro" 仅适用于 64 位模式。见下表中的寄存器代码。
**+i**
    在浮点指令中使用，当一个操作数是 FPU 寄存器栈中的 ST(i) 时。数字 i（范围可以从 0
    到 7）被加到加号左边给出的十六进制字节上，形成单个操作码字节。

与 +rb, +rw, +rd, +ro 相关的寄存器代码如下表： ::

    字节寄存器 REX.B Reg字段    字寄存器    双字寄存器  四字寄存器（仅64位模式）
        AL      None    0       AX          EAX         RAX
        CL      None    1       CX          ECX         RCX
        DL      None    2       DX          EDX         RDX
        BL      None    3       BX          EBX         RBX
        AH      N.E.    4       SP  None    ESP         N/A
        CH      N.E.    5       BP  None    EBP         N/A
        DH      N.E.    6       SI  None    ESI         N/A
        BH      N.E.    7       DI  None    EDI         N/A
        SPL     Yes     4       SP  None    ESP         RSP
        BPL     Yes     5       BP  None    EBP         RBP
        SIL     Yes     6       SI  None    ESI         RSI
        DIL     Yes     7       DI  None    EDI         RDI
        以下寄存器仅64位模式可用
        R8B     Yes     0       R8W         R8D         R8
        R9B     Yes     1       R9W         R9D         R9
        R10B    Yes     2       R10W        R10D        R10
        R11B    Yes     3       R11W        R11D        R11
        R12B    Yes     4       R12W        R12D        R12
        R13B    Yes     5       R13W        R13D        R13
        R14B    Yes     6       R14W        R14D        R14
        R15B    Yes     7       R15W        R15D        R15

    其中 N.E. 表示不可编码（Not Encodable）

指令信息
---------

